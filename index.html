<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie City Survival</title>
    <link rel="icon" type="image/png" href="https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/ZOH-Favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
            user-select: none;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #game-canvas {
            display: block;
            background: #1a3a1a;
        }
        
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 20px;
            border-radius: 8px;
            border: 2px solid #4a4a4a;
            pointer-events: auto;
            min-width: 220px;
            transition: opacity 0.3s;
        }
        
        #hud.collapsed {
            display: none;
        }
        
        #hud-toggle {
            display: block;
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            color: white;
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            z-index: 101;
            pointer-events: auto;
            font-size: 0.9rem;
        }
        
        #mini-stats {
            display: none;
            position: absolute;
            bottom: 190px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            padding: 8px 15px;
            pointer-events: none;
            font-size: 0.85rem;
            white-space: nowrap;
        }
        
        #mini-stats span {
            margin: 0 10px;
            color: #4ecdc4;
            font-weight: bold;
        }
        
        /* Hide mini-stats - not needed with stats button */
        
        #hud h2 {
            color: #ff6b6b;
            margin-bottom: 8px;
            font-size: 1.2rem;
        }
        
        .hud-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 1rem;
        }
        
        .hud-value {
            color: #4ecdc4;
            font-weight: bold;
        }
        
        #ammo-count {
            color: #ffd166;
        }
        
        #lives-container {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            align-items: center;
        }
        
        .life-heart {
            color: #ff6b6b;
            font-size: 1.5rem;
        }
        
        .life-heart.empty {
            color: #555;
        }
        
        #weapon-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 20px;
            border-radius: 8px;
            border: 2px solid #4a4a4a;
            pointer-events: auto;
            text-align: center;
            display: none !important;
        }
        
        #weapon-name {
            color: #ffd166;
            font-size: 1.3rem;
            margin-bottom: 5px;
        }
        
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        
        .zoom-btn {
            width: 50px;
            height: 50px;
            background: rgba(40, 40, 40, 0.8);
            border-radius: 8px;
            border: 2px solid #666;
            color: white;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        #instructions {
            position: absolute;
            top: 80px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 20px;
            border-radius: 8px;
            border: 2px solid #4a4a4a;
            max-width: 300px;
            pointer-events: auto;
        }
        
        #instructions h3 {
            color: #4ecdc4;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        #instructions p {
            font-size: 0.9rem;
            margin-bottom: 5px;
            line-height: 1.4;
        }
        
        #save-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(78, 205, 196, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 300;
        }
        
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
            padding: 20px;
            overflow-y: auto;  /* Allow scrolling if content too tall */
        }
        
        .screen-title {
            font-size: 2.5rem;
            color: #ff6b6b;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.7);
        }
        
        .screen-subtitle {
            font-size: 1rem;
            color: #4ecdc4;
            margin-bottom: 10px;
            max-width: 800px;
            line-height: 1.5;
        }
        
        .screen-stats {
            background: rgba(40, 40, 40, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #4a4a4a;
            min-width: 250px;
        }
        
        .screen-stats div {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .screen-stats span:last-child {
            color: #ffd166;
            font-weight: bold;
        }
        
        .btn {
            background: linear-gradient(to bottom, #ff6b6b, #c44545);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.3rem;
            border-radius: 8px;
            margin: 15px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid #ff8a8a;
            font-weight: bold;
            min-width: 200px;
        }
        
        .btn:hover {
            background: linear-gradient(to bottom, #ff8a8a, #d45555);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        .difficulty-btn {
            transition: all 0.2s;
            opacity: 0.7;
        }
        
        .difficulty-btn:hover {
            transform: translateY(-2px);
            opacity: 1;
        }
        
        .difficulty-btn.selected {
            opacity: 1;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 250px;
            pointer-events: none;
            z-index: 150;
            display: none;
        }
        
        #joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(100, 100, 100, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            pointer-events: auto;
        }
        
        #joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #shoot-button {
            position: absolute;
            bottom: 50px;
            right: 30px;
            width: 100px;
            height: 100px;
            background: rgba(255, 107, 107, 0.7);
            border: 4px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
        }
        
        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }
            
            #zoom-controls {
                display: none !important;
            }
            
            #weapon-info {
                display: none !important;
            }
            
            #pause-btn {
                width: 40px !important;
                height: 40px !important;
                font-size: 1.2rem !important;
                top: 15px !important;
                right: 15px !important;
            }
            
            #hud {
                top: 70px !important;
                left: 15px !important;
                font-size: 0.85rem;
                max-width: 200px;
            }
            
            #hud.collapsed {
                display: none;
            }
            
            #instructions {
                display: none !important;
            }
            
            /* Make start screen scrollable and compact on mobile */
            .screen-title {
                font-size: 1.5rem !important;
                margin-bottom: 3px !important;
            }
            
            .screen-subtitle {
                font-size: 0.8rem !important;
                margin-bottom: 5px !important;
            }
            
            .difficulty-btn {
                padding: 8px 12px !important;
                font-size: 0.85rem !important;
                min-width: 80px !important;
            }
            
            .screen-stats {
                padding: 8px !important;
                font-size: 0.8rem !important;
                margin: 5px 0 !important;
            }
            
            .btn {
                padding: 8px 20px !important;
                font-size: 0.95rem !important;
                min-width: 140px !important;
                margin: 5px !important;
            }
            
            .screen img {
                max-width: 150px !important;
                max-height: 80px !important;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="game-ui">
            <button id="hud-toggle">üìä STATS</button>
            
            <div id="hud" class="collapsed">
                <h2>ZOMBIE SURVIVAL</h2>
                <div class="hud-item">
                    <span>Stage:</span>
                    <span id="stage" class="hud-value">1</span>
                </div>
                <div class="hud-item">
                    <span>Left:</span>
                    <span id="zombies-left" class="hud-value">200</span>
                </div>
                <div class="hud-item">
                    <span>Killed:</span>
                    <span id="zombies-killed" class="hud-value">0</span>
                </div>
                <div class="hud-item">
                    <span>Ammo:</span>
                    <span id="ammo-count" class="hud-value">20</span>
                </div>
                <div id="lives-container">
                    <span>Lives:</span>
                    <div id="lives-display">
                        <span class="life-heart">‚ô•</span>
                        <span class="life-heart">‚ô•</span>
                        <span class="life-heart">‚ô•</span>
                        <span class="life-heart">‚ô•</span>
                        <span class="life-heart">‚ô•</span>
                    </div>
                </div>
            </div>
            
            <button id="pause-btn" style="position: absolute; top: 15px; right: 15px; width: 50px; height: 50px; background: rgba(0,0,0,0.7); border: 2px solid #4a4a4a; border-radius: 8px; color: white; font-size: 1.5rem; cursor: pointer; pointer-events: auto; display: flex; align-items: center; justify-content: center;">‚è∏</button>
            
            <div id="save-indicator">GAME SAVED</div>
            
            <div id="zoom-controls">
                <button id="zoom-out" class="zoom-btn">-</button>
                <button id="zoom-in" class="zoom-btn">+</button>
            </div>
            
            <div id="instructions">
                <h3>CONTROLS</h3>
                <p>‚Ä¢ WASD/Arrows: Move</p>
                <p>‚Ä¢ Mouse: Aim & Click to Shoot</p>
                <p>‚Ä¢ Scroll: Zoom</p>
            </div>
        </div>
        
        <div id="start-screen" class="screen">
            <button onclick="window.history.back()" style="position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.7); border: 2px solid #4a4a4a; border-radius: 8px; color: white; padding: 10px 20px; cursor: pointer; font-size: 1rem; font-weight: bold;">‚Üê BACK</button>
            
            <img src="https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/ZOH-Logo-real.png" alt="Zombie Outbreak Honolulu" style="max-width: 200px; max-height: 100px; margin-bottom: 5px;">
            <h1 class="screen-title" style="font-size: 2rem; margin-bottom: 5px;">ZOMBIE SURVIVAL GAME MAY TAKE 30 SECONDS TO LOAD</h1>
            <p class="screen-subtitle" style="font-size: 0.9rem; margin-bottom: 8px;">Survive 10 stages of zombies! Game is in development and currently being modified & tested. Please allow around 30 seconds for game assets to load! No save options available! Zombie Counter Is Broken But Stages Complete. Beware that each boss doubles in HP each level. The last stage has three boss zombies!!!</p>
            
            <div style="margin: 10px 0;">
                <p style="font-size: 1rem; margin-bottom: 8px; color: #ffd166;">SELECT DIFFICULTY:</p>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button id="easy-btn" class="difficulty-btn" style="padding: 10px 20px; font-size: 1rem; background: linear-gradient(to bottom, #4ecdc4, #3ab0a8); border: 3px solid #4ecdc4; border-radius: 8px; color: white; cursor: pointer; font-weight: bold; min-width: 100px;">EASY</button>
                    <button id="medium-btn" class="difficulty-btn selected" style="padding: 10px 20px; font-size: 1rem; background: linear-gradient(to bottom, #ffd166, #f4a259); border: 3px solid #ffd166; border-radius: 8px; color: #2d3142; cursor: pointer; font-weight: bold; min-width: 100px;">MEDIUM</button>
                    <button id="hard-btn" class="difficulty-btn" style="padding: 10px 20px; font-size: 1rem; background: linear-gradient(to bottom, #ff6b6b, #c92a2a); border: 3px solid #ff6b6b; border-radius: 8px; color: white; cursor: pointer; font-weight: bold; min-width: 100px;">HARD</button>
                </div>
            </div>
            
            <div class="screen-stats" style="padding: 10px; margin: 8px 0; min-width: 250px;">
                <div><span>Stage:</span><span id="start-stage">1</span></div>
                <div><span>Zombies:</span><span id="start-zombies">200</span></div>
                <div><span>Ammo:</span><span>20</span></div>
                <div><span>Lives:</span><span>5</span></div>
            </div>
            <button id="start-btn" class="btn" style="padding: 10px 30px; font-size: 1.1rem; margin-top: 8px;">NEW GAME</button>
            <button id="continue-btn" class="btn hidden" style="padding: 10px 30px; font-size: 1.1rem; margin-top: 5px; background: linear-gradient(to bottom, #4ecdc4, #3a9d94);">CONTINUE</button>
        </div>
        
        <div id="cutscene-screen" class="screen hidden" style="background: black; padding: 0;">
            <div id="cutscene-placeholder" style="display: none; width: 100%; height: 100%; flex-direction: column; align-items: center; justify-content: center; color: white;">
                <h1 id="cutscene-title" style="font-size: 4rem; margin-bottom: 20px; text-shadow: 0 0 20px rgba(255,107,107,0.8);">INTRO</h1>
                <p id="cutscene-subtitle" style="font-size: 1.5rem; opacity: 0.8;">Preparing for battle...</p>
            </div>
            <video id="cutscene-video" style="width: 100%; height: 100%; object-fit: contain;" preload="auto">
                <source id="cutscene-source" src="" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <button id="skip-cutscene-btn" style="position: absolute; bottom: 30px; right: 30px; background: rgba(0,0,0,0.8); border: 2px solid #fff; border-radius: 8px; color: white; padding: 12px 24px; cursor: pointer; font-size: 1rem; font-weight: bold; z-index: 10; pointer-events: auto;">SKIP ‚Üí</button>
        </div>
        
        <div id="stage-complete-screen" class="screen hidden">
            <h1 class="screen-title">STAGE COMPLETE!</h1>
            <p class="screen-subtitle">Ready for the next wave?</p>
            <div class="screen-stats">
                <div><span>Completed:</span><span id="completed-stage">1</span></div>
                <div><span>Killed:</span><span id="completed-kills">0</span></div>
                <div><span>Ammo Found:</span><span id="completed-ammo">0</span></div>
                <div><span>Next Wave:</span><span id="next-stage-zombies">300</span></div>
            </div>
            <button id="next-stage-btn" class="btn">NEXT STAGE</button>
            <button onclick="window.history.back()" class="btn" style="background: linear-gradient(to bottom, #4a4a4a, #2a2a2a); border-color: #666; margin-top: 10px;">‚Üê BACK TO GAMES</button>
        </div>
        
        <div id="game-over-screen" class="screen hidden">
            <h1 class="screen-title">GAME OVER</h1>
            <p class="screen-subtitle">You have been overwhelmed...</p>
            <div class="screen-stats">
                <div><span>Stage:</span><span id="final-stage">1</span></div>
                <div><span>Killed:</span><span id="final-kills">0</span></div>
                <div><span>Ammo:</span><span id="final-ammo">0</span></div>
            </div>
            <button id="restart-btn" class="btn">RESTART</button>
            <button onclick="window.history.back()" class="btn" style="background: linear-gradient(to bottom, #4a4a4a, #2a2a2a); border-color: #666; margin-top: 10px;">‚Üê BACK TO GAMES</button>
        </div>
        
        <div id="pause-screen" class="screen hidden">
            <h1 class="screen-title">PAUSED</h1>
            <p class="screen-subtitle">Game is paused</p>
            <div class="screen-stats">
                <div><span>Stage:</span><span id="pause-stage">1</span></div>
                <div><span>Zombies Left:</span><span id="pause-zombies">200</span></div>
                <div><span>Lives:</span><span id="pause-lives">3</span></div>
                <div><span>Ammo:</span><span id="pause-ammo">20</span></div>
            </div>
            <button id="resume-btn" class="btn">RESUME</button>
            <button id="quit-btn" class="btn" style="background: linear-gradient(to bottom, #666, #444); border-color: #888;">QUIT TO MENU</button>
            <button onclick="window.history.back()" class="btn" style="background: linear-gradient(to bottom, #4a4a4a, #2a2a2a); border-color: #666; margin-top: 10px;">‚Üê BACK TO GAMES</button>
        </div>
        
        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <div id="joystick-area">
                <div id="joystick-stick"></div>
            </div>
            <div id="shoot-button">SHOOT</div>
        </div>
    </div>

    <script>
        const CONFIG = {
            CANVAS_WIDTH: 6000,
            CANVAS_HEIGHT: 6000,
            STARTING_AMMO: 20,
            STARTING_LIVES: 5,  // Start with 5 lives instead of 3
            ZOMBIES_PER_STAGE: [200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100],
            TOTAL_STAGES: 10,
            PLAYER_SPEED: 4,
            PLAYER_SIZE: 75,  // Increased from 50 (50% larger)
            
            // ===== ZOMBIE SPEED (EASY TO ADJUST) =====
            // Lower = slower zombies, Higher = faster zombies
            // Examples: 0.5-1.5 = Easy, 1.0-2.0 = Medium, 1.5-3.0 = Hard
            ZOMBIE_SPEED_MIN: 0.8,
            ZOMBIE_SPEED_MAX: 2.0,
            // =========================================
            
            // ===== BOSS SPEED (EASY TO ADJUST) =====
            // Examples: 1.0 = Slow, 1.5 = Medium, 2.0 = Fast
            BOSS_SPEED: 1.5,
            // =======================================
            
            ZOMBIE_SIZE: 68,  // Increased from 45 (50% larger)
            SHOTGUN_DAMAGE: 40,
            SHOTGUN_RANGE: 250,
            SHOTGUN_SPREAD: 0.4,
            SHOTGUN_PELLETS: 6,
            SHOTGUN_FIRE_RATE: 800,
            AMMO_DROP_CHANCE: 0.3,
            HIDDEN_AMMO_COUNT: 50,
            MIN_ZOOM: 0.5,
            MAX_ZOOM: 3,
            DEFAULT_ZOOM: 1,
            ZOOM_STEP: 0.25,
            INVINCIBILITY_TIME: 1000,
            BUILDING_WIDTH: 150,
            BUILDING_HEIGHT: 150
        };

        // Fixed building positions (same every stage)
        const BUILDING_POSITIONS = [
            // First 5x5 grid (original 25)
            {x: 400, y: 400}, {x: 900, y: 400}, {x: 1400, y: 400}, {x: 1900, y: 400}, {x: 2400, y: 400},
            {x: 400, y: 900}, {x: 900, y: 900}, {x: 1400, y: 900}, {x: 1900, y: 900}, {x: 2400, y: 900},
            {x: 400, y: 1400}, {x: 900, y: 1400}, {x: 1400, y: 1400}, {x: 1900, y: 1400}, {x: 2400, y: 1400},
            {x: 400, y: 1900}, {x: 900, y: 1900}, {x: 1400, y: 1900}, {x: 1900, y: 1900}, {x: 2400, y: 1900},
            {x: 400, y: 2400}, {x: 900, y: 2400}, {x: 1400, y: 2400}, {x: 1900, y: 2400}, {x: 2400, y: 2400},
            // Second 5x5 grid (new 25)
            {x: 3200, y: 400}, {x: 3700, y: 400}, {x: 4200, y: 400}, {x: 4700, y: 400}, {x: 5200, y: 400},
            {x: 3200, y: 900}, {x: 3700, y: 900}, {x: 4200, y: 900}, {x: 4700, y: 900}, {x: 5200, y: 900},
            {x: 3200, y: 1400}, {x: 3700, y: 1400}, {x: 4200, y: 1400}, {x: 4700, y: 1400}, {x: 5200, y: 1400},
            {x: 3200, y: 1900}, {x: 3700, y: 1900}, {x: 4200, y: 1900}, {x: 4700, y: 1900}, {x: 5200, y: 1900},
            {x: 3200, y: 2400}, {x: 3700, y: 2400}, {x: 4200, y: 2400}, {x: 4700, y: 2400}, {x: 5200, y: 2400},
            // Bottom section buildings
            {x: 800, y: 3200}, {x: 1600, y: 3200}, {x: 2400, y: 3200}, {x: 3200, y: 3200}, {x: 4000, y: 3200},
            {x: 800, y: 4000}, {x: 1600, y: 4000}, {x: 2400, y: 4000}, {x: 3200, y: 4000}, {x: 4000, y: 4000},
            {x: 800, y: 4800}, {x: 1600, y: 4800}, {x: 2400, y: 4800}, {x: 3200, y: 4800}, {x: 4000, y: 4800},
            {x: 800, y: 5400}, {x: 1600, y: 5400}, {x: 2400, y: 5400}, {x: 3200, y: 5400}, {x: 4000, y: 5400}
        ];

        // ============================================
        // PASTE YOUR IMAGE URLS HERE (LINE 302)
        // Leave blank "" to use colored shapes
        // ============================================
        const SPRITES = {
            player:  "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/tank-2.png",
            zombie1: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-1.png",
            zombie2: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss%202.png",
            zombie3: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-3.png",
            zombie4: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-12.png",
            zombie5: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Zombie-10.png",
            zombie6: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Zombie-11.png",
            zombie7: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Zombie-7.png",
            zombie8: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Zombie-8.png",
            zombie9: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Zombie-9.png",
            zombie10: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Zombie-12.png",  // Stage 6 new zombie
            zombie11: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Zombie-6.png",  // Stage 7 new zombie
            zombie12: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Zombie-3.png",  // Stage 8 new zombie
            zombie13: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Zombie-1.png",  // Stage 9 new zombie
            zombie14: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Zombie-2.png",  // Stage 10 new zombie
            ammo: "",
            // Boss sprites for each stage
            boss1: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-13.png",
            boss2: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-15.png",   // Stage 2 boss
            boss3: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-14.png",   // Stage 3 boss
            boss4: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-4.png",   // Stage 4 boss
            boss5: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-5.png",   // Stage 5 boss
            boss6: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-6.png",   // Stage 6 boss 1
            boss7: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-7.png",   // Stage 7 boss 1
            boss8: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-8.png",   // Stage 8 boss 1
            boss9: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-9.png",   // Stage 9 boss 1
            boss10: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-10.png",  // Stage 10 boss 1
            boss11: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-11.png",  // Stage 10 boss 2
            boss12: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Boss-12.png",  // Stage 10 boss 3
            // 70 Building sprites (building1-building70)
            // Using the Oahu Roofing image you provided
            building1: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Building-2.png",
            building2: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building3: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building4: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building5: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building6: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building7: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building8: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building9: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building10: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building11: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building12: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building13: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building14: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building15: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building16: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building17: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building18: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building19: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building20: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building21: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building22: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building23: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building24: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building25: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building26: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building27: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building28: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building29: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building30: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building31: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building32: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building33: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building34: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building35: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building36: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building37: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building38: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building39: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building40: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building41: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building42: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building43: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building44: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building45: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building46: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building47: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building48: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building49: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building50: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building51: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building52: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building53: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building54: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building55: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building56: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building57: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building58: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building59: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building60: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building61: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building62: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building63: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building64: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building65: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building66: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building67: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building68: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building69: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            building70: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Oahu Roofing.png",
            // Stage-specific background tiles
            groundTile1: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Tile-4.png",   // Stage 1 background
            groundTile2: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Tile-5.png",   // Stage 2 background
            groundTile3: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Tile-3.png",   // Stage 3 background
            groundTile4: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Tile-2.png",   // Stage 4 background
            groundTile5: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Tile-1.png",   // Stage 5 background
            groundTile6: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Tile-6.png",   // Stage 6 background
            groundTile7: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Tile-7.png",   // Stage 7 background
            groundTile8: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Tile-8.png",   // Stage 8 background
            groundTile9: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Tile-9.png",   // Stage 9 background
            groundTile10: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Tile-3.png",   // Stage 10 background
            // Cutscene videos (MP4 format) - 30 seconds each
            introCutscene: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Ad-1-Zombie.mp4", // Plays when starting a new game
            stage1Cutscene: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Ad-1-Zombie.mp4", // Plays before stage 1 begins
            stage2Cutscene: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Ad-1-Zombie.mp4", // Plays before stage 2 begins
            stage3Cutscene: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Ad-1-Zombie.mp4", // Plays before stage 3 begins
            stage4Cutscene: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Ad-1-Zombie.mp4", // Plays before stage 4 begins
            stage5Cutscene: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Ad-1-Zombie.mp4",  // Plays before stage 5 begins
            // Boss weapon sprite
            coconutBomb: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Coconut%20bomb.png"
        };

        // ============================================
        // BACKGROUND MUSIC FOR EACH STAGE
        // Paste your MP3 URLs here (one per stage)
        // Leave blank "" for no music
        // ============================================
        const STAGE_MUSIC = {
            stage1: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Stage-1-song.mp3",
            stage2: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Stage-1-song.mp3",   // Stage 2 music
            stage3: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Stage-1-song.mp3",   // Stage 3 music
            stage4: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Stage-1-song.mp3",   // Stage 4 music
            stage5: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Stage-1-song.mp3",   // Stage 5 music
            stage6: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Stage-1-song.mp3",   // Stage 6 music
            stage7: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Stage-1-song.mp3",   // Stage 7 music
            stage8: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Stage-1-song.mp3",   // Stage 8 music
            stage9: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Stage-1-song.mp3",   // Stage 9 music
            stage10: "https://github.com/TitanBusinessPros/Zombie-Outbreak-Honolulu/raw/main/Stage-1-song.mp3"   // Stage 10 music
        };

        // Load images
        const IMG = {};
        for (let key in SPRITES) {
            IMG[key] = new Image();
            if (SPRITES[key]) IMG[key].src = SPRITES[key];
        }

        let gameState = {
            stage: 1,
            zombiesKilled: 0,
            zombiesLeft: CONFIG.ZOMBIES_PER_STAGE[0],
            playerLives: CONFIG.STARTING_LIVES,
            playerAmmo: CONFIG.STARTING_AMMO,
            totalAmmoCollected: 0,
            gameRunning: false,
            gameOver: false,
            stageComplete: false,
            lastShotTime: 0,
            lastHitTime: 0,
            zoom: CONFIG.DEFAULT_ZOOM,
            isInvincible: false,
            bossActive: false,
            bossPlayedSound: false,
            isPaused: false,
            difficulty: 'medium'  // easy, medium, or hard
        };
        
        // Difficulty presets
        const DIFFICULTY_PRESETS = {
            easy: {
                ZOMBIE_SPEED_MIN: 0.5,
                ZOMBIE_SPEED_MAX: 1.5,
                BOSS_SPEED: 1.0,
                ACID_RANGE: 80,
                STARTING_LIVES: 7
            },
            medium: {
                ZOMBIE_SPEED_MIN: 0.8,
                ZOMBIE_SPEED_MAX: 2.0,
                BOSS_SPEED: 1.5,
                ACID_RANGE: 100,
                STARTING_LIVES: 5
            },
            hard: {
                ZOMBIE_SPEED_MIN: 1.2,
                ZOMBIE_SPEED_MAX: 2.8,
                BOSS_SPEED: 2.2,
                ACID_RANGE: 150,
                STARTING_LIVES: 3
            }
        };


        const player = {
            x: CONFIG.CANVAS_WIDTH / 2,
            y: CONFIG.CANVAS_HEIGHT / 2,
            size: CONFIG.PLAYER_SIZE,
            speed: CONFIG.PLAYER_SPEED,
            angle: 0
        };

        const bosses = [];  // Changed to array for multiple bosses
        const coconutBombs = [];  // Boss projectiles
        const acidPukes = [];  // Zombie acid attacks
        
        // Coconut bomb configuration
        const BOMB_CONFIG = {
            SIZE: 30,
            SPEED: 3,
            EXPLOSION_RADIUS: 120,
            EXPLOSION_DAMAGE: 1,
            THROW_INTERVAL: 3000,  // Boss throws bomb every 3 seconds
            FUSE_TIME: 2000  // Bomb explodes 2 seconds after thrown
        };
        
        // Acid puke configuration
        const ACID_CONFIG = {
            SPLASH_RADIUS: 100,  // Area of effect for acid splash
            DAMAGE: 1,
            
            // ===== ACID PUKE RANGE (EASY TO ADJUST) =====
            // How close zombie needs to be to puke at you
            // Examples: 100 = Very Close, 150 = Close, 200 = Medium, 300 = Far
            RANGE: 100,  // Reduced from 200
            // ============================================
            
            PUKE_INTERVAL_FAST: 5000,  // Zombies 1, 2, 3 puke every 5 seconds
            PUKE_INTERVAL_SLOW: 10000,  // Zombies 4-14 puke every 10 seconds
            CLOSE_RANGE: 150,  // Or when within 150px of player
            SPLASH_DURATION: 1500  // Splash stays on ground for 1.5 seconds
        };
        const zombies = [];
        const ammoPacks = [];
        const bloodSplatters = [];
        const bulletTraces = [];
        const buildings = [];
        const keys = new Set();
        const mouse = { x: 0, y: 0 };

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Background music
        let backgroundMusic = null;

        // ============================================
        // CUTSCENE FUNCTIONS
        // ============================================
        
        let currentCutsceneType = null; // Track if we're playing intro or stage
        
        function playCutscene(cutsceneType, stage) {
            currentCutsceneType = cutsceneType; // Remember what type of cutscene this is
            
            // Determine which cutscene to play
            let videoUrl = "";
            let titleText = "";
            let subtitleText = "";
            
            if (cutsceneType === "intro") {
                videoUrl = SPRITES.introCutscene;
                titleText = "ZOMBIE OUTBREAK";
                subtitleText = "The infection has begun...";
            } else if (cutsceneType === "stage" && stage >= 1 && stage <= 5) {
                videoUrl = SPRITES[`stage${stage}Cutscene`];
                titleText = `STAGE ${stage}`;
                subtitleText = `${CONFIG.ZOMBIES_PER_STAGE[stage - 1]} zombies incoming...`;
            }
            
            // Show cutscene screen
            const cutsceneScreen = document.getElementById('cutscene-screen');
            const cutsceneVideo = document.getElementById('cutscene-video');
            const cutsceneSource = document.getElementById('cutscene-source');
            const cutscenePlaceholder = document.getElementById('cutscene-placeholder');
            const cutsceneTitle = document.getElementById('cutscene-title');
            const cutsceneSubtitle = document.getElementById('cutscene-subtitle');
            const skipBtn = document.getElementById('skip-cutscene-btn');
            
            // Show cutscene screen
            cutsceneScreen.classList.remove('hidden');
            
            // If video URL exists, play video
            if (videoUrl) {
                cutsceneVideo.style.display = 'block';
                cutscenePlaceholder.style.display = 'none';
                
                // Set video source
                cutsceneSource.src = videoUrl;
                cutsceneVideo.load();
                
                // Play video
                const playPromise = cutsceneVideo.play();
                if (playPromise !== undefined) {
                    playPromise.catch(err => {
                        console.log('Video autoplay failed:', err);
                        // Show placeholder if video fails
                        showPlaceholder();
                    });
                }
                
                // Video ended - move to game
                cutsceneVideo.onended = () => {
                    afterCutscene(stage);
                };
            } else {
                // No video URL - show placeholder screen
                cutsceneVideo.style.display = 'none';
                showPlaceholder();
            }
            
            function showPlaceholder() {
                cutsceneVideo.style.display = 'none';
                cutscenePlaceholder.style.display = 'flex';
                cutsceneTitle.textContent = titleText;
                cutsceneSubtitle.textContent = subtitleText;
                
                // Auto-advance after 3 seconds
                setTimeout(() => {
                    if (!cutsceneScreen.classList.contains('hidden')) {
                        afterCutscene(stage);
                    }
                }, 3000);
            }
            
            // Skip button
            skipBtn.onclick = () => {
                if (cutsceneVideo.style.display !== 'none') {
                    cutsceneVideo.pause();
                    cutsceneVideo.currentTime = 0;
                    cutsceneVideo.src = ''; // Fully stop video
                }
                afterCutscene(stage);
            };
            
            // Auto-skip after 30 seconds as backup (for videos)
            if (videoUrl) {
                setTimeout(() => {
                    if (!cutsceneScreen.classList.contains('hidden')) {
                        cutsceneVideo.pause();
                        cutsceneVideo.currentTime = 0;
                        cutsceneVideo.src = '';
                        afterCutscene(stage);
                    }
                }, 30000);
            }
        }
        
        function afterCutscene(stage) {
            // Stop and reset video
            const cutsceneVideo = document.getElementById('cutscene-video');
            cutsceneVideo.pause();
            cutsceneVideo.currentTime = 0;
            cutsceneVideo.src = ''; // Clear source to fully stop
            
            // Hide cutscene screen
            document.getElementById('cutscene-screen').classList.add('hidden');
            
            // If this was the intro cutscene, play stage 1 cutscene next
            if (currentCutsceneType === 'intro') {
                setTimeout(() => {
                    playCutscene('stage', 1);
                }, 200);
            } else if (stage) {
                // This was a stage cutscene, start the game
                startStage(stage);
            }
        }
        
        function startStage(stage) {
            // Hide all screens
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('stage-complete-screen').classList.add('hidden');
            
            // Set stage
            gameState.stage = stage;
            
            // Start the stage
            startStageDirectly();
        }

        // ============================================
        // SAVE/LOAD FUNCTIONS
        // ============================================
        
        // Save/Load game functions
        function saveGame() {
            const saveData = {
                stage: gameState.stage,
                playerLives: gameState.playerLives,
                playerAmmo: gameState.playerAmmo,
                totalAmmoCollected: gameState.totalAmmoCollected,
                highestStage: Math.max(gameState.stage, parseInt(localStorage.getItem('highestStage') || '1'))
            };
            localStorage.setItem('zombieGameSave', JSON.stringify(saveData));
            localStorage.setItem('highestStage', saveData.highestStage.toString());
            
            // Show save indicator
            const indicator = document.getElementById('save-indicator');
            indicator.style.opacity = '1';
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
            
            console.log('Game saved:', saveData);
        }

        function loadGame() {
            const saveData = localStorage.getItem('zombieGameSave');
            if (saveData) {
                try {
                    const data = JSON.parse(saveData);
                    return data;
                } catch (e) {
                    console.error('Failed to load save data');
                    return null;
                }
            }
            return null;
        }

        function clearSave() {
            localStorage.removeItem('zombieGameSave');
        }

        function playStageMusic(stage) {
            // Stop current music
            if (backgroundMusic) {
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0;
            }

            // Get music URL for this stage
            const musicUrl = STAGE_MUSIC['stage' + stage];
            
            if (musicUrl) {
                backgroundMusic = new Audio(musicUrl);
                backgroundMusic.loop = true;
                backgroundMusic.volume = 0.3;
                
                // Play music (handle autoplay restrictions)
                backgroundMusic.play().catch(err => {
                    console.log("Music autoplay prevented. Click to enable sound.");
                });
            }
        }

        function stopStageMusic() {
            if (backgroundMusic) {
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0;
            }
        }

        // Initialize buildings with fixed positions
        function initBuildings() {
            buildings.length = 0;
            for (let i = 0; i < BUILDING_POSITIONS.length; i++) {
                buildings.push({
                    id: i + 1,
                    x: BUILDING_POSITIONS[i].x,
                    y: BUILDING_POSITIONS[i].y,
                    width: CONFIG.BUILDING_WIDTH,
                    height: CONFIG.BUILDING_HEIGHT
                });
            }
        }

        // Check collision with buildings
        function checkBuildingCollision(x, y, size) {
            for (const building of buildings) {
                if (x + size > building.x && 
                    x - size < building.x + building.width &&
                    y + size > building.y && 
                    y - size < building.y + building.height) {
                    return true;
                }
            }
            return false;
        }

        // Get valid position avoiding buildings
        function getValidPosition(size) {
            let attempts = 0;
            while (attempts < 100) {
                const x = Math.random() * (CONFIG.CANVAS_WIDTH - size * 2) + size;
                const y = Math.random() * (CONFIG.CANVAS_HEIGHT - size * 2) + size;
                if (!checkBuildingCollision(x, y, size)) {
                    return {x, y};
                }
                attempts++;
            }
            return {x: CONFIG.CANVAS_WIDTH / 2, y: CONFIG.CANVAS_HEIGHT / 2};
        }

        function setupEvents() {
            window.addEventListener('keydown', (e) => {
                if (gameState.gameRunning) {
                    const key = e.key.toLowerCase();
                    if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright',' '].includes(key)) {
                        e.preventDefault();
                        keys.add(key);
                        if (key === ' ') shoot();
                    }
                }
            });
            
            window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));
            window.addEventListener('blur', () => keys.clear());
            
            canvas.addEventListener('mousemove', (e) => {
                const r = canvas.getBoundingClientRect();
                mouse.x = e.clientX - r.left;
                mouse.y = e.clientY - r.top;
            });
            
            canvas.addEventListener('mousedown', (e) => {
                if (gameState.gameRunning) shoot();
                e.preventDefault();
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0 && gameState.zoom < CONFIG.MAX_ZOOM) gameState.zoom += CONFIG.ZOOM_STEP;
                else if (e.deltaY > 0 && gameState.zoom > CONFIG.MIN_ZOOM) gameState.zoom -= CONFIG.ZOOM_STEP;
            }, {passive: false});
            
            document.getElementById('zoom-in').addEventListener('click', () => {
                if (gameState.zoom < CONFIG.MAX_ZOOM) gameState.zoom += CONFIG.ZOOM_STEP;
            });
            
            document.getElementById('zoom-out').addEventListener('click', () => {
                if (gameState.zoom > CONFIG.MIN_ZOOM) gameState.zoom -= CONFIG.ZOOM_STEP;
            });
            
            // Difficulty selection buttons
            const difficultyButtons = {
                easy: document.getElementById('easy-btn'),
                medium: document.getElementById('medium-btn'),
                hard: document.getElementById('hard-btn')
            };
            
            Object.keys(difficultyButtons).forEach(difficulty => {
                difficultyButtons[difficulty].addEventListener('click', () => {
                    // Remove selected class from all buttons
                    Object.values(difficultyButtons).forEach(btn => btn.classList.remove('selected'));
                    // Add selected class to clicked button
                    difficultyButtons[difficulty].classList.add('selected');
                    // Apply difficulty settings
                    applyDifficulty(difficulty);
                });
            });
            
            document.getElementById('start-btn').addEventListener('click', () => {
                clearSave();  // Clear save when starting new game
                // Play intro cutscene first, then it will trigger stage 1 cutscene
                playCutscene('intro', 1);
            });
            
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            document.getElementById('next-stage-btn').addEventListener('click', nextStage);
            
            document.getElementById('pause-btn').addEventListener('click', togglePause);
            document.getElementById('resume-btn').addEventListener('click', togglePause);
            document.getElementById('quit-btn').addEventListener('click', quitToMenu);
            
            // HUD toggle for mobile
            document.getElementById('hud-toggle').addEventListener('click', () => {
                const hud = document.getElementById('hud');
                const toggle = document.getElementById('hud-toggle');
                hud.classList.toggle('collapsed');
                
                if (hud.classList.contains('collapsed')) {
                    toggle.textContent = 'üìä STATS';
                } else {
                    toggle.textContent = '‚ùå CLOSE';
                }
            });
            
            // ESC key to pause
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && gameState.gameRunning && !gameState.gameOver && !gameState.stageComplete) {
                    togglePause();
                }
            });
            
            // Prevent page visibility from stopping the game
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden && gameState.gameRunning && !gameState.isPaused) {
                    // Resume game loop if it stopped
                    requestAnimationFrame(gameLoop);
                }
            });
            
            // Pinch-to-zoom for mobile
            let lastTouchDistance = 0;
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (lastTouchDistance > 0) {
                        const delta = distance - lastTouchDistance;
                        if (Math.abs(delta) > 5) {
                            if (delta > 0) {
                                // Pinch out = zoom in
                                gameState.zoom = Math.min(CONFIG.MAX_ZOOM, gameState.zoom + CONFIG.ZOOM_STEP);
                            } else {
                                // Pinch in = zoom out
                                gameState.zoom = Math.max(CONFIG.MIN_ZOOM, gameState.zoom - CONFIG.ZOOM_STEP);
                            }
                        }
                    }
                    lastTouchDistance = distance;
                }
            });
            
            canvas.addEventListener('touchend', (e) => {
                if (e.touches.length < 2) {
                    lastTouchDistance = 0;
                }
            });
            
            // Mobile joystick controls
            setupMobileControls();
        }

        function setupMobileControls() {
            const joystickArea = document.getElementById('joystick-area');
            const joystickStick = document.getElementById('joystick-stick');
            const shootButton = document.getElementById('shoot-button');
            
            let joystickActive = false;
            let joystickId = null;
            let joystickCenterX = 0;
            let joystickCenterY = 0;
            let moveDirection = { x: 0, y: 0 };
            
            joystickArea.addEventListener('touchstart', (e) => {
                if (!gameState.gameRunning || gameState.isPaused) return;
                e.preventDefault();
                joystickActive = true;
                joystickId = e.changedTouches[0].identifier;
                const rect = joystickArea.getBoundingClientRect();
                joystickCenterX = rect.left + rect.width / 2;
                joystickCenterY = rect.top + rect.height / 2;
            });
            
            joystickArea.addEventListener('touchmove', (e) => {
                if (!joystickActive || !gameState.gameRunning || gameState.isPaused) return;
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickId) {
                        const deltaX = touch.clientX - joystickCenterX;
                        const deltaY = touch.clientY - joystickCenterY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        const maxDistance = 60;
                        
                        let moveX = deltaX;
                        let moveY = deltaY;
                        
                        if (distance > maxDistance) {
                            moveX = (deltaX / distance) * maxDistance;
                            moveY = (deltaY / distance) * maxDistance;
                        }
                        
                        joystickStick.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
                        
                        // Store movement direction for continuous movement
                        if (distance > 5) {
                            moveDirection.x = deltaX / distance;
                            moveDirection.y = deltaY / distance;
                            moveDirection.strength = Math.min(distance / maxDistance, 1);
                        } else {
                            moveDirection.x = 0;
                            moveDirection.y = 0;
                            moveDirection.strength = 0;
                        }
                        
                        break;
                    }
                }
            });
            
            joystickArea.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickId) {
                        joystickActive = false;
                        joystickId = null;
                        joystickStick.style.transform = 'translate(-50%, -50%)';
                        moveDirection.x = 0;
                        moveDirection.y = 0;
                        moveDirection.strength = 0;
                        break;
                    }
                }
            });
            
            // Apply continuous movement in update loop
            window.applyJoystickMovement = function() {
                if (moveDirection.strength > 0 && gameState.gameRunning && !gameState.isPaused) {
                    const newX = player.x + moveDirection.x * player.speed * moveDirection.strength;
                    const newY = player.y + moveDirection.y * player.speed * moveDirection.strength;
                    
                    // Check building collision
                    if (!checkBuildingCollision(newX, newY, player.size)) {
                        player.x = newX;
                        player.y = newY;
                    } else {
                        // Try sliding along walls
                        if (!checkBuildingCollision(newX, player.y, player.size)) {
                            player.x = newX;
                        } else if (!checkBuildingCollision(player.x, newY, player.size)) {
                            player.y = newY;
                        }
                    }
                    
                    // Keep player in bounds
                    player.x = Math.max(player.size, Math.min(CONFIG.CANVAS_WIDTH - player.size, player.x));
                    player.y = Math.max(player.size, Math.min(CONFIG.CANVAS_HEIGHT - player.size, player.y));
                }
            };
            
            // Shoot button
            shootButton.addEventListener('touchstart', (e) => {
                if (!gameState.gameRunning || gameState.isPaused) return;
                e.preventDefault();
                autoAimAndShoot();  // Use auto-aim on mobile
            });
        }

        function togglePause() {
            if (!gameState.gameRunning || gameState.gameOver || gameState.stageComplete) return;
            
            gameState.isPaused = !gameState.isPaused;
            const pauseScreen = document.getElementById('pause-screen');
            
            if (gameState.isPaused) {
                // Update pause screen info
                document.getElementById('pause-stage').textContent = gameState.stage;
                document.getElementById('pause-zombies').textContent = gameState.zombiesLeft;
                document.getElementById('pause-lives').textContent = gameState.playerLives;
                document.getElementById('pause-ammo').textContent = gameState.playerAmmo;
                pauseScreen.classList.remove('hidden');
                
                // Pause music
                if (backgroundMusic) {
                    backgroundMusic.pause();
                }
            } else {
                pauseScreen.classList.add('hidden');
                
                // Resume music
                if (backgroundMusic) {
                    backgroundMusic.play().catch(err => console.log("Music resume failed"));
                }
            }
        }

        function quitToMenu() {
            gameState.isPaused = false;
            gameState.gameRunning = false;
            stopStageMusic();
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
            saveGame();
        }

        function initGame() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initBuildings();
            spawnInitialZombies();
            spawnHiddenAmmo();
            spawnBoss();  // Spawn boss on every stage
            updateHUD();
            updateLivesDisplay();
            setupEvents();
            
            // Prevent mobile from sleeping/pausing
            if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen').catch(err => {
                    console.log('Wake lock not supported:', err);
                });
            }
            
            // Keep screen active on mobile
            let keepAliveInterval = setInterval(() => {
                if (gameState.gameRunning && !gameState.isPaused) {
                    // Dummy operation to keep JS active
                    const dummy = Date.now();
                }
            }, 5000);
            
            // Check for save data
            const saveData = loadGame();
            const continueBtn = document.getElementById('continue-btn');
            if (saveData && saveData.stage > 1) {
                continueBtn.classList.remove('hidden');
                continueBtn.addEventListener('click', () => {
                    // Load saved game
                    gameState.stage = saveData.stage;
                    gameState.playerLives = saveData.playerLives;
                    gameState.playerAmmo = saveData.playerAmmo;
                    gameState.totalAmmoCollected = saveData.totalAmmoCollected;
                    gameState.zombiesLeft = CONFIG.ZOMBIES_PER_STAGE[gameState.stage - 1];
                    
                    // Reset for current stage
                    zombies.length = 0;
                    bosses.length = 0;
                    ammoPacks.length = 0;
                    spawnInitialZombies();
                    spawnHiddenAmmo();
                    spawnBoss();
                    updateHUD();
                    updateLivesDisplay();
                    
                    document.getElementById('start-screen').classList.add('hidden');
                    gameState.gameRunning = true;
                    playStageMusic(gameState.stage);
                });
            }
            
            requestAnimationFrame(gameLoop);
        }

        function spawnInitialZombies() {
            const n = Math.min(30, gameState.zombiesLeft);
            for (let i = 0; i < n; i++) spawnZombie();
            
            // Always spawn zombie 8 and 9 on every stage
            spawnGhostZombie(8);
            spawnGhostZombie(9);
        }

        function spawnGhostZombie(type) {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            switch(side) {
                case 0: x = -50; y = Math.random() * CONFIG.CANVAS_HEIGHT; break;
                case 1: x = CONFIG.CANVAS_WIDTH + 50; y = Math.random() * CONFIG.CANVAS_HEIGHT; break;
                case 2: x = Math.random() * CONFIG.CANVAS_WIDTH; y = -50; break;
                case 3: x = Math.random() * CONFIG.CANVAS_WIDTH; y = CONFIG.CANVAS_HEIGHT + 50; break;
            }
            
            zombies.push({
                x, y,
                size: CONFIG.ZOMBIE_SIZE,
                speed: CONFIG.ZOMBIE_SPEED_MIN + Math.random() * (CONFIG.ZOMBIE_SPEED_MAX - CONFIG.ZOMBIE_SPEED_MIN),
                type: type,
                health: 50 + Math.floor(Math.random() * 50),
                canPassThroughBuildings: true,
                isGhost: true
            });
        }

        function spawnZombie() {
            if (gameState.zombiesLeft <= 0) return;
            const side = Math.floor(Math.random() * 4);
            let x, y;
            switch(side) {
                case 0: x = -50; y = Math.random() * CONFIG.CANVAS_HEIGHT; break;
                case 1: x = CONFIG.CANVAS_WIDTH + 50; y = Math.random() * CONFIG.CANVAS_HEIGHT; break;
                case 2: x = Math.random() * CONFIG.CANVAS_WIDTH; y = -50; break;
                case 3: x = Math.random() * CONFIG.CANVAS_WIDTH; y = CONFIG.CANVAS_HEIGHT + 50; break;
            }
            
            // Determine zombie types based on stage
            let maxZombieType;
            switch(gameState.stage) {
                case 1: maxZombieType = 3; break;   // Zombies 1-3
                case 2: maxZombieType = 4; break;   // Zombies 1-4
                case 3: maxZombieType = 6; break;   // Zombies 1-6
                case 4: maxZombieType = 8; break;   // Zombies 1-8
                case 5: maxZombieType = 9; break;   // Zombies 1-9
                case 6: maxZombieType = 10; break;  // All zombies 1-10
                case 7: maxZombieType = 11; break;  // All zombies 1-11
                case 8: maxZombieType = 12; break;  // All zombies 1-12
                case 9: maxZombieType = 13; break;  // All zombies 1-13
                case 10: maxZombieType = 14; break; // All zombies 1-14
                default: maxZombieType = 3; break;
            }
            
            const zombieType = Math.floor(Math.random() * maxZombieType) + 1;
            
            zombies.push({
                x, y,
                size: CONFIG.ZOMBIE_SIZE,
                speed: CONFIG.ZOMBIE_SPEED_MIN + Math.random() * (CONFIG.ZOMBIE_SPEED_MAX - CONFIG.ZOMBIE_SPEED_MIN),
                type: zombieType,
                health: 50 + Math.floor(Math.random() * 50),
                canPassThroughBuildings: (zombieType === 8 || zombieType === 9)  // Zombies 8 & 9 are ghosts
            });
            gameState.zombiesLeft--;
        }

        function spawnHiddenAmmo() {
            for (let i = 0; i < CONFIG.HIDDEN_AMMO_COUNT; i++) {
                const pos = getValidPosition(15);
                ammoPacks.push({
                    x: pos.x,
                    y: pos.y,
                    amount: 5 + Math.floor(Math.random() * 10)
                });
            }
        }

        function spawnBoss() {
            bosses.length = 0;  // Clear any existing bosses
            
            // Boss health triples each stage
            const baseHealth = 2400;
            const bossHealth = baseHealth * Math.pow(3, gameState.stage - 1);
            
            // Determine number of bosses
            let bossCount = 1;
            let bossIds = [gameState.stage];  // Default: use stage number as boss ID
            
            if (gameState.stage >= 6 && gameState.stage <= 7) {
                bossCount = 2;
                bossIds = [gameState.stage, gameState.stage];  // Two of the same boss
            } else if (gameState.stage === 8 || gameState.stage === 9) {
                bossCount = 3;  // 3 bosses on stages 8 and 9
                bossIds = [gameState.stage, gameState.stage, gameState.stage];
            } else if (gameState.stage === 10) {
                bossCount = 3;
                bossIds = [10, 11, 12];  // Three different bosses
            }
            
            // Spawn bosses at different positions
            for (let i = 0; i < bossCount; i++) {
                const xOffset = (i - (bossCount - 1) / 2) * 300;
                bosses.push({
                    x: CONFIG.CANVAS_WIDTH / 2 + xOffset,
                    y: 100 + (i * 50),
                    size: CONFIG.ZOMBIE_SIZE * 3,
                    speed: CONFIG.BOSS_SPEED,
                    health: bossHealth,
                    maxHealth: bossHealth,
                    stage: gameState.stage,
                    bossId: bossIds[i],
                    soundPlayed: false
                });
            }
            
            gameState.bossActive = true;
        }

        function gameLoop() {
            try {
                if (gameState.gameRunning && !gameState.gameOver && !gameState.stageComplete && !gameState.isPaused) {
                    update();
                    draw();
                    
                    // Check stage completion - only count non-ghost zombies
                    const nonGhostZombies = zombies.filter(z => !z.isGhost);
                    const regularZombiesGone = gameState.zombiesLeft <= 0 && nonGhostZombies.length === 0;
                    const bossDefeated = !gameState.bossActive || bosses.length === 0;
                    
                    if (regularZombiesGone && bossDefeated) {
                        completeStage();
                    }
                    
                    // Spawn regular zombies
                    if (gameState.zombiesLeft > 0 && zombies.length < 50 && Math.random() < 0.05) {
                        spawnZombie();
                    }
                    
                    // Spawn ghost zombies periodically (10% chance when spawning)
                    if (zombies.length < 50 && Math.random() < 0.01) {
                        const ghostType = Math.random() < 0.5 ? 8 : 9;
                        spawnGhostZombie(ghostType);
                    }
                } else if (gameState.isPaused) {
                    // Still draw when paused
                    draw();
                }
            } catch (err) {
                console.error('Game loop error:', err);
                // Continue running even if error occurs
            }
            requestAnimationFrame(gameLoop);
        }

        function update() {
            try { updatePlayer(); } catch (e) { console.error('updatePlayer error:', e); }
            try {
                if (window.applyJoystickMovement) {
                    window.applyJoystickMovement();
                }
            } catch (e) { console.error('applyJoystickMovement error:', e); }
            try { updateZombies(); } catch (e) { console.error('updateZombies error:', e); }
            try { updateBoss(); } catch (e) { console.error('updateBoss error:', e); }
            try { updateCoconutBombs(); } catch (e) { console.error('updateCoconutBombs error:', e); }
            try { updateAcidPukes(); } catch (e) { console.error('updateAcidPukes error:', e); }
            try { updateAmmo(); } catch (e) { console.error('updateAmmo error:', e); }
            try { updateBulletTraces(); } catch (e) { console.error('updateBulletTraces error:', e); }
            try { updateHUD(); } catch (e) { console.error('updateHUD error:', e); }
            try {
                if (gameState.isInvincible && Date.now() - gameState.lastHitTime > CONFIG.INVINCIBILITY_TIME) {
                    gameState.isInvincible = false;
                }
            } catch (e) { console.error('invincibility error:', e); }
        }

        function updateBoss() {
            if (!gameState.bossActive) return;
            
            for (let i = bosses.length - 1; i >= 0; i--) {
                const boss = bosses[i];
                
                // Move towards player
                const dx = player.x - boss.x;
                const dy = player.y - boss.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Boss can pass through buildings
                    boss.x += (dx / distance) * boss.speed;
                    boss.y += (dy / distance) * boss.speed;
                }
                
                // Throw coconut bomb at player
                const now = Date.now();
                if (!boss.lastBombTime) boss.lastBombTime = now;
                if (now - boss.lastBombTime > BOMB_CONFIG.THROW_INTERVAL) {
                    throwCoconutBomb(boss, player.x, player.y);
                    boss.lastBombTime = now;
                }
                
                // Play boss sound when near player (200 pixels)
                if (distance < 200 && !boss.soundPlayed) {
                    playBossSound();
                    boss.soundPlayed = true;
                }
                
                // Reset sound flag when boss moves away
                if (distance > 250) {
                    boss.soundPlayed = false;
                }
                
                // Check collision with player
                if (!gameState.isInvincible && distance < player.size + boss.size) {
                    takeDamage();
                }
                
                // Check if boss is dead
                if (boss.health <= 0) {
                    bloodSplatters.push({x: boss.x, y: boss.y, size: 30 + Math.random() * 20, alpha: 1});
                    // Boss drops lots of ammo
                    ammoPacks.push({x: boss.x, y: boss.y, amount: 30});
                    
                    // Award +1 life for killing boss (max 5 lives)
                    if (gameState.playerLives < 5) {
                        gameState.playerLives++;
                        updateLivesDisplay();
                    }
                    
                    bosses.splice(i, 1);
                }
            }
            
            // If all bosses are dead, deactivate boss mode
            if (bosses.length === 0) {
                gameState.bossActive = false;
            }
        }

        function playBossSound() {
            try {
                const ac = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ac.createOscillator(), gain = ac.createGain();
                osc.connect(gain);
                gain.connect(ac.destination);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, ac.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, ac.currentTime + 0.5);
                gain.gain.setValueAtTime(0.4, ac.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ac.currentTime + 0.5);
                osc.start(ac.currentTime);
                osc.stop(ac.currentTime + 0.5);
            } catch(e) {}
        }
        
        // ============================================
        // COCONUT BOMB SYSTEM
        // ============================================
        
        function throwCoconutBomb(boss, targetX, targetY) {
            const dx = targetX - boss.x;
            const dy = targetY - boss.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            coconutBombs.push({
                x: boss.x,
                y: boss.y,
                vx: (dx / distance) * BOMB_CONFIG.SPEED,
                vy: (dy / distance) * BOMB_CONFIG.SPEED,
                thrownTime: Date.now(),
                size: BOMB_CONFIG.SIZE
            });
        }
        
        function updateCoconutBombs() {
            const now = Date.now();
            
            for (let i = coconutBombs.length - 1; i >= 0; i--) {
                const bomb = coconutBombs[i];
                
                // Move bomb
                bomb.x += bomb.vx;
                bomb.y += bomb.vy;
                
                // Check if bomb should explode (after fuse time)
                if (now - bomb.thrownTime > BOMB_CONFIG.FUSE_TIME) {
                    explodeCoconutBomb(bomb);
                    coconutBombs.splice(i, 1);
                    continue;
                }
                
                // Remove if off screen
                if (bomb.x < -100 || bomb.x > CONFIG.CANVAS_WIDTH + 100 ||
                    bomb.y < -100 || bomb.y > CONFIG.CANVAS_HEIGHT + 100) {
                    coconutBombs.splice(i, 1);
                }
            }
        }
        
        function explodeCoconutBomb(bomb) {
            // Play explosion sound
            playExplosionSound();
            
            // Create explosion visual effect
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const distance = Math.random() * BOMB_CONFIG.EXPLOSION_RADIUS;
                bloodSplatters.push({
                    x: bomb.x + Math.cos(angle) * distance,
                    y: bomb.y + Math.sin(angle) * distance,
                    size: 10 + Math.random() * 15,
                    alpha: 1,
                    color: 'rgba(255, 150, 0, 0.8)'  // Orange explosion color
                });
            }
            
            // Check if player is in explosion radius
            const dx = player.x - bomb.x;
            const dy = player.y - bomb.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < BOMB_CONFIG.EXPLOSION_RADIUS && !gameState.isInvincible) {
                takeDamage();
            }
        }
        
        function playExplosionSound() {
            try {
                const ac = new (window.AudioContext || window.webkitAudioContext)();
                
                // Low boom
                const o1 = ac.createOscillator();
                const g1 = ac.createGain();
                o1.connect(g1);
                g1.connect(ac.destination);
                o1.frequency.value = 60;
                g1.gain.value = 0.3;
                o1.start(0);
                g1.gain.exponentialRampToValueAtTime(0.00001, ac.currentTime + 0.4);
                o1.stop(ac.currentTime + 0.4);
                
                // High crackle
                const o2 = ac.createOscillator();
                const g2 = ac.createGain();
                o2.connect(g2);
                g2.connect(ac.destination);
                o2.type = 'sawtooth';
                o2.frequency.value = 200;
                g2.gain.value = 0.15;
                o2.start(0);
                g2.gain.exponentialRampToValueAtTime(0.00001, ac.currentTime + 0.2);
                o2.stop(ac.currentTime + 0.2);
            } catch(e) {}
        }
        
        // ============================================
        // ACID PUKE SYSTEM (Zombies 1, 2, 3)
        // ============================================
        
        function pukeAcid(zombie, targetX, targetY) {
            // Determine puke color based on zombie type
            let pukeColor;
            if (zombie.type >= 1 && zombie.type <= 3) {
                pukeColor = { r: 0, g: 255, b: 0 };  // Green
            } else if (zombie.type >= 4 && zombie.type <= 6) {
                pukeColor = { r: 255, g: 0, b: 0 };  // Red
            } else if (zombie.type >= 7 && zombie.type <= 9) {
                pukeColor = { r: 0, g: 100, b: 255 };  // Blue
            } else if (zombie.type >= 10 && zombie.type <= 14) {
                pukeColor = { r: 255, g: 255, b: 0 };  // Yellow
            } else {
                pukeColor = { r: 0, g: 255, b: 0 };  // Default green
            }
            
            // Play puke sound
            playPukeSound();
            
            // Create acid splash on ground at target location
            acidPukes.push({
                x: targetX,
                y: targetY,
                radius: ACID_CONFIG.SPLASH_RADIUS,
                createdTime: Date.now(),
                alpha: 1,
                color: pukeColor
            });
            
            // Create visual splash particles
            for (let i = 0; i < 15; i++) {
                const angle = (Math.PI * 2 * i) / 15;
                const distance = Math.random() * ACID_CONFIG.SPLASH_RADIUS;
                bloodSplatters.push({
                    x: targetX + Math.cos(angle) * distance,
                    y: targetY + Math.sin(angle) * distance,
                    size: 8 + Math.random() * 12,
                    alpha: 1,
                    color: `rgba(${pukeColor.r}, ${pukeColor.g}, ${pukeColor.b}, 0.7)`
                });
            }
        }
        
        function updateAcidPukes() {
            const now = Date.now();
            
            for (let i = acidPukes.length - 1; i >= 0; i--) {
                const acid = acidPukes[i];
                
                // Check if player is in splash radius
                const dx = player.x - acid.x;
                const dy = player.y - acid.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < acid.radius && !gameState.isInvincible) {
                    takeDamage();
                }
                
                // Fade out over time
                const age = now - acid.createdTime;
                acid.alpha = 1 - (age / ACID_CONFIG.SPLASH_DURATION);
                
                // Remove after duration
                if (age > ACID_CONFIG.SPLASH_DURATION) {
                    acidPukes.splice(i, 1);
                }
            }
        }
        
        function playPukeSound() {
            try {
                const ac = new (window.AudioContext || window.webkitAudioContext)();
                
                // Gurgling low sound
                const o1 = ac.createOscillator();
                const g1 = ac.createGain();
                o1.connect(g1);
                g1.connect(ac.destination);
                o1.type = 'sawtooth';
                o1.frequency.value = 120;
                o1.frequency.exponentialRampToValueAtTime(80, ac.currentTime + 0.3);
                g1.gain.value = 0.2;
                g1.gain.exponentialRampToValueAtTime(0.00001, ac.currentTime + 0.3);
                o1.start(0);
                o1.stop(ac.currentTime + 0.3);
            } catch(e) {}
        }


        function updatePlayer() {
            let dx = 0, dy = 0;
            if (keys.has('w') || keys.has('arrowup')) dy -= 1;
            if (keys.has('s') || keys.has('arrowdown')) dy += 1;
            if (keys.has('a') || keys.has('arrowleft')) dx -= 1;
            if (keys.has('d') || keys.has('arrowright')) dx += 1;
            if (dx && dy) { dx *= 0.707; dy *= 0.707; }
            
            // Calculate new position
            let newX = player.x + dx * player.speed;
            let newY = player.y + dy * player.speed;
            
            // Keep within bounds
            newX = Math.max(player.size, Math.min(CONFIG.CANVAS_WIDTH - player.size, newX));
            newY = Math.max(player.size, Math.min(CONFIG.CANVAS_HEIGHT - player.size, newY));
            
            // Check building collision
            if (!checkBuildingCollision(newX, newY, player.size)) {
                player.x = newX;
                player.y = newY;
            } else {
                // Try sliding along walls
                if (!checkBuildingCollision(newX, player.y, player.size)) {
                    player.x = newX;
                } else if (!checkBuildingCollision(player.x, newY, player.size)) {
                    player.y = newY;
                }
            }
            
            const wmx = (mouse.x / gameState.zoom) + player.x - (canvas.width / 2 / gameState.zoom);
            const wmy = (mouse.y / gameState.zoom) + player.y - (canvas.height / 2 / gameState.zoom);
            player.angle = Math.atan2(wmy - player.y, wmx - player.x);
        }

        function updateZombies() {
            const now = Date.now();
            
            for (let i = zombies.length - 1; i >= 0; i--) {
                const z = zombies[i];
                const dx = player.x - z.x, dy = player.y - z.y;
                const d = Math.sqrt(dx*dx + dy*dy);
                
                // All zombies (except ghosts) can puke acid
                if (!z.isGhost) {
                    if (!z.lastPukeTime) z.lastPukeTime = now;
                    
                    // Zombies 1-3 puke every 5 seconds, others every 10 seconds
                    const pukeInterval = (z.type === 1 || z.type === 2 || z.type === 3) 
                        ? ACID_CONFIG.PUKE_INTERVAL_FAST 
                        : ACID_CONFIG.PUKE_INTERVAL_SLOW;
                    
                    // Puke at interval OR when close to player
                    const shouldPuke = (now - z.lastPukeTime > pukeInterval) || 
                                      (d < ACID_CONFIG.CLOSE_RANGE && now - z.lastPukeTime > 2000);
                    
                    if (shouldPuke && d < ACID_CONFIG.RANGE) {
                        pukeAcid(z, player.x, player.y);
                        z.lastPukeTime = now;
                    }
                }
                
                if (d > 0) {
                    const newX = z.x + (dx/d) * z.speed;
                    const newY = z.y + (dy/d) * z.speed;
                    
                    // Zombies 8 and 9 can pass through buildings
                    if (z.canPassThroughBuildings) {
                        z.x = newX;
                        z.y = newY;
                    } else {
                        // Check building collision for normal zombies
                        if (!checkBuildingCollision(newX, newY, z.size)) {
                            z.x = newX;
                            z.y = newY;
                        } else {
                            // Try to slide around buildings
                            if (!checkBuildingCollision(newX, z.y, z.size)) {
                                z.x = newX;
                            } else if (!checkBuildingCollision(z.x, newY, z.size)) {
                                z.y = newY;
                            }
                        }
                    }
                }
                
                if (!gameState.isInvincible && d < player.size + z.size) takeDamage();
                if (z.health <= 0) {
                    if (Math.random() < CONFIG.AMMO_DROP_CHANCE) {
                        ammoPacks.push({x: z.x, y: z.y, amount: 2 + Math.floor(Math.random() * 4)});
                    }
                    bloodSplatters.push({x: z.x, y: z.y, size: 10 + Math.random() * 15, alpha: 1});
                    zombies.splice(i, 1);
                    // Ghost zombies don't count toward stage zombies
                    if (!z.isGhost) {
                        gameState.zombiesKilled++;
                    }
                }
            }
        }

        function takeDamage() {
            gameState.playerLives--;
            gameState.lastHitTime = Date.now();
            gameState.isInvincible = true;
            updateLivesDisplay();
            for (let i = 0; i < 5; i++) {
                bloodSplatters.push({
                    x: player.x + (Math.random() - 0.5) * 40,
                    y: player.y + (Math.random() - 0.5) * 40,
                    size: 3 + Math.random() * 5,
                    alpha: 0.8
                });
            }
            if (gameState.playerLives <= 0) gameOver();
        }

        function updateAmmo() {
            for (let i = ammoPacks.length - 1; i >= 0; i--) {
                const a = ammoPacks[i];
                const dx = player.x - a.x, dy = player.y - a.y;
                const d = Math.sqrt(dx*dx + dy*dy);
                if (d < player.size + 15) {
                    gameState.playerAmmo += a.amount;
                    gameState.totalAmmoCollected += a.amount;
                    ammoPacks.splice(i, 1);
                }
            }
        }

        function updateBulletTraces() {
            for (let i = bulletTraces.length - 1; i >= 0; i--) {
                bulletTraces[i].life -= 0.05;
                if (bulletTraces[i].life <= 0) bulletTraces.splice(i, 1);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const vx = player.x - canvas.width / (2 * gameState.zoom);
            const vy = player.y - canvas.height / (2 * gameState.zoom);
            
            ctx.save();
            ctx.scale(gameState.zoom, gameState.zoom);
            ctx.translate(-vx, -vy);
            
            // Background - use stage-specific tile
            const tileKey = 'groundTile' + gameState.stage;
            if (IMG[tileKey] && IMG[tileKey].complete && IMG[tileKey].naturalWidth > 0 && SPRITES[tileKey]) {
                const pattern = ctx.createPattern(IMG[tileKey], 'repeat');
                ctx.fillStyle = pattern;
            } else {
                ctx.fillStyle = '#1a3a1a';
            }
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            
            // Draw buildings
            for (let i = 0; i < buildings.length; i++) {
                const b = buildings[i];
                const buildingImg = IMG['building' + b.id];
                if (buildingImg && buildingImg.complete && buildingImg.naturalWidth > 0 && SPRITES['building' + b.id]) {
                    ctx.drawImage(buildingImg, b.x, b.y, b.width, b.height);
                } else {
                    ctx.fillStyle = '#555577';
                    ctx.fillRect(b.x, b.y, b.width, b.height);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(b.x, b.y, b.width, b.height);
                }
            }
            
            // Ammo
            for (const a of ammoPacks) {
                if (IMG.ammo && IMG.ammo.complete && IMG.ammo.naturalWidth > 0 && SPRITES.ammo) {
                    ctx.drawImage(IMG.ammo, a.x - 15, a.y - 15, 30, 30);
                } else {
                    ctx.fillStyle = '#fd6';
                    ctx.beginPath();
                    ctx.arc(a.x, a.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('+' + a.amount, a.x, a.y);
            }
            
            // Bullets
            for (const t of bulletTraces) {
                ctx.strokeStyle = `rgba(255,255,0,${t.life})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(t.start.x, t.start.y);
                ctx.lineTo(t.end.x, t.end.y);
                ctx.stroke();
            }
            
            // Blood
            for (let i = bloodSplatters.length - 1; i >= 0; i--) {
                const s = bloodSplatters[i];
                const color = s.color || `rgba(139,0,0,${s.alpha})`;
                ctx.fillStyle = color.includes('rgba') ? color.replace(/[\d.]+\)$/, `${s.alpha})`) : `rgba(139,0,0,${s.alpha})`;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();
                s.alpha -= 0.01;
                if (s.alpha <= 0) bloodSplatters.splice(i, 1);
            }
            
            // Zombies
            for (const z of zombies) {
                const zi = IMG['zombie' + z.type];
                
                // Make ghost zombies (8 & 9) semi-transparent
                if (z.canPassThroughBuildings) {
                    ctx.globalAlpha = 0.7;
                }
                
                if (zi && zi.complete && zi.naturalWidth > 0 && SPRITES['zombie' + z.type]) {
                    ctx.save();
                    ctx.translate(z.x, z.y);
                    ctx.drawImage(zi, -z.size/2, -z.size/2, z.size, z.size);
                    ctx.restore();
                } else {
                    const hue = (z.type * 20) % 360;
                    ctx.fillStyle = `hsl(${hue},70%,40%)`;
                    ctx.beginPath();
                    ctx.arc(z.x, z.y, z.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Reset alpha
                ctx.globalAlpha = 1;
                
                const hp = Math.max(0, z.health / 100);
                ctx.fillStyle = '#f00';
                ctx.fillRect(z.x - 20, z.y - 35, 40, 5);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(z.x - 20, z.y - 35, 40 * hp, 5);
            }
            
            // Bosses
            if (gameState.bossActive && bosses.length > 0) {
                for (const boss of bosses) {
                    const bossImg = IMG['boss' + boss.bossId];
                    
                    // Make boss semi-transparent (ghost effect)
                    ctx.globalAlpha = 0.8;
                    
                    if (bossImg && bossImg.complete && bossImg.naturalWidth > 0 && SPRITES['boss' + boss.bossId]) {
                        ctx.save();
                        ctx.translate(boss.x, boss.y);
                        ctx.drawImage(bossImg, -boss.size/2, -boss.size/2, boss.size, boss.size);
                        ctx.restore();
                    } else {
                        // Fallback color changes per boss
                        const colors = ['#8b0000', '#8b008b', '#ff4500', '#ff8c00', '#ff0000', '#dc143c', '#b22222', '#8b0000', '#a52a2a', '#800000', '#660000', '#4d0000'];
                        ctx.fillStyle = colors[boss.bossId - 1] || '#8b0000';
                        ctx.beginPath();
                        ctx.arc(boss.x, boss.y, boss.size/2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Reset alpha
                    ctx.globalAlpha = 1;
                    
                    // Boss health bar (bigger)
                    const bossHp = Math.max(0, boss.health / boss.maxHealth);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(boss.x - 60, boss.y - boss.size/2 - 20, 120, 10);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(boss.x - 60, boss.y - boss.size/2 - 20, 120 * bossHp, 10);
                }
            }
            
            // Draw coconut bombs
            for (const bomb of coconutBombs) {
                const bombImg = IMG.coconutBomb;
                
                if (bombImg && bombImg.complete && bombImg.naturalWidth > 0) {
                    ctx.save();
                    ctx.translate(bomb.x, bomb.y);
                    // Rotate bomb as it flies
                    const rotation = (Date.now() - bomb.thrownTime) / 100;
                    ctx.rotate(rotation);
                    ctx.drawImage(bombImg, -bomb.size/2, -bomb.size/2, bomb.size, bomb.size);
                    ctx.restore();
                } else {
                    // Fallback: brown circle
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.arc(bomb.x, bomb.y, bomb.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Fuse spark
                    ctx.fillStyle = '#ff4500';
                    ctx.beginPath();
                    ctx.arc(bomb.x, bomb.y - bomb.size/2, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw acid splashes (ground pools)
            for (const acid of acidPukes) {
                const c = acid.color || { r: 0, g: 255, b: 0 };  // Default green
                
                // Draw fading splash circle on ground
                ctx.fillStyle = `rgba(${c.r}, ${c.g}, ${c.b}, ${acid.alpha * 0.4})`;
                ctx.beginPath();
                ctx.arc(acid.x, acid.y, acid.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner brighter circle
                const brightR = Math.min(255, c.r + 50);
                const brightG = Math.min(255, c.g + 50);
                const brightB = Math.min(255, c.b + 50);
                ctx.fillStyle = `rgba(${brightR}, ${brightG}, ${brightB}, ${acid.alpha * 0.6})`;
                ctx.beginPath();
                ctx.arc(acid.x, acid.y, acid.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // Glowing edge
                ctx.strokeStyle = `rgba(${c.r}, ${c.g}, ${c.b}, ${acid.alpha * 0.8})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(acid.x, acid.y, acid.radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Player
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            if (IMG.player && IMG.player.complete && IMG.player.naturalWidth > 0 && SPRITES.player) {
                if (gameState.isInvincible && Math.floor(Date.now()/200) % 2 === 0) ctx.globalAlpha = 0.5;
                ctx.drawImage(IMG.player, -player.size/2, -player.size/2, player.size, player.size);
                ctx.globalAlpha = 1;
            } else {
                if (gameState.isInvincible && Math.floor(Date.now()/200) % 2 === 0) ctx.fillStyle = 'rgba(255,100,100,0.7)';
                else ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.arc(0, 0, player.size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            // Only show gun on desktop (not mobile)
            if (window.innerWidth > 768) {
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(player.size/3, -3, 25, 6);
                ctx.fillStyle = '#654321';
                ctx.fillRect(player.size/3 + 25, -2, 10, 4);
            }
            ctx.restore();
            
            ctx.restore();
            
            // Boss HP bars on HUD (top center) - show all bosses
            if (gameState.bossActive && bosses.length > 0) {
                const barWidth = 300;
                const barHeight = 20;
                const barSpacing = 30;
                
                for (let i = 0; i < bosses.length; i++) {
                    const boss = bosses[i];
                    const barX = canvas.width / 2 - barWidth / 2;
                    const barY = 20 + (i * barSpacing);
                    const bossHp = Math.max(0, boss.health / boss.maxHealth);
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
                    ctx.fillStyle = '#f00';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(barX, barY, barWidth * bossHp, barHeight);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    const label = bosses.length > 1 ? `BOSS ${i + 1}` : 'BOSS';
                    ctx.fillText(label, canvas.width / 2, barY - 10);
                }
            }
            
            // Crosshair
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(mouse.x - 15, mouse.y);
            ctx.lineTo(mouse.x + 15, mouse.y);
            ctx.moveTo(mouse.x, mouse.y - 15);
            ctx.lineTo(mouse.x, mouse.y + 15);
            ctx.stroke();
            
            // Mobile auto-aim indicator
            if (window.innerWidth <= 768) {
                try {
                    const target = findNearestZombie();
                    if (target && typeof target.x === 'number' && typeof target.y === 'number') {
                        const screenX = (target.x - camX) * gameState.zoom + canvas.width / 2;
                        const screenY = (target.y - camY) * gameState.zoom + canvas.height / 2;
                        
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 40, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Crosshair on target
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(screenX - 15, screenY);
                        ctx.lineTo(screenX + 15, screenY);
                        ctx.moveTo(screenX, screenY - 15);
                        ctx.lineTo(screenX, screenY + 15);
                        ctx.stroke();
                    }
                } catch (err) {
                    // Silently fail if target indicator has issues
                }
            }
        }

        function shoot() {
            if (gameState.playerAmmo <= 0) return;
            const now = Date.now();
            if (now - gameState.lastShotTime < CONFIG.SHOTGUN_FIRE_RATE) return;
            
            gameState.playerAmmo--;
            gameState.lastShotTime = now;
            playShotgunSound();
            
            for (let i = 0; i < CONFIG.SHOTGUN_PELLETS; i++) {
                const spread = (Math.random() - 0.5) * CONFIG.SHOTGUN_SPREAD;
                const angle = player.angle + spread;
                const ex = player.x + Math.cos(angle) * CONFIG.SHOTGUN_RANGE;
                const ey = player.y + Math.sin(angle) * CONFIG.SHOTGUN_RANGE;
                bulletTraces.push({start: {x: player.x, y: player.y}, end: {x: ex, y: ey}, life: 1});
                
                // Check all bosses
                if (gameState.bossActive) {
                    for (const boss of bosses) {
                        const ldx = ex - player.x, ldy = ey - player.y;
                        const ll = Math.sqrt(ldx*ldx + ldy*ldy);
                        const lux = ldx/ll, luy = ldy/ll;
                        const tcx = boss.x - player.x, tcy = boss.y - player.y;
                        const proj = tcx*lux + tcy*luy;
                        const clamp = Math.max(0, Math.min(ll, proj));
                        const cpx = player.x + clamp*lux, cpy = player.y + clamp*luy;
                        const dx = boss.x - cpx, dy = boss.y - cpy;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist <= boss.size/2) {
                            boss.health -= CONFIG.SHOTGUN_DAMAGE;
                            bloodSplatters.push({x: cpx, y: cpy, size: 8 + Math.random() * 12, alpha: 1});
                        }
                    }
                }
                
                // Check zombie hits
                for (const z of zombies) {
                    const ldx = ex - player.x, ldy = ey - player.y;
                    const ll = Math.sqrt(ldx*ldx + ldy*ldy);
                    const lux = ldx/ll, luy = ldy/ll;
                    const tcx = z.x - player.x, tcy = z.y - player.y;
                    const proj = tcx*lux + tcy*luy;
                    const clamp = Math.max(0, Math.min(ll, proj));
                    const cpx = player.x + clamp*lux, cpy = player.y + clamp*luy;
                    const dx = z.x - cpx, dy = z.y - cpy;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist <= z.size/2) {
                        z.health -= CONFIG.SHOTGUN_DAMAGE;
                        bloodSplatters.push({x: cpx, y: cpy, size: 5 + Math.random() * 10, alpha: 1});
                    }
                }
            }
            updateHUD();
        }

        function findNearestZombie() {
            if (!zombies || !Array.isArray(zombies)) return null;
            
            let nearest = null;
            let minDist = Infinity;
            
            // Check all zombies
            for (const z of zombies) {
                if (!z || typeof z.x !== 'number' || typeof z.y !== 'number') continue;
                
                const dx = z.x - player.x;
                const dy = z.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < minDist && dist < CONFIG.SHOTGUN_RANGE * 2) {
                    minDist = dist;
                    nearest = z;
                }
            }
            
            // Check all bosses
            if (gameState.bossActive && bosses && Array.isArray(bosses)) {
                for (const boss of bosses) {
                    if (!boss || typeof boss.x !== 'number' || typeof boss.y !== 'number') continue;
                    
                    const dx = boss.x - player.x;
                    const dy = boss.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < minDist && dist < CONFIG.SHOTGUN_RANGE * 2) {
                        minDist = dist;
                        nearest = boss;
                    }
                }
            }
            
            return nearest;
        }

        function autoAimAndShoot() {
            try {
                const target = findNearestZombie();
                if (target && typeof target.x === 'number' && typeof target.y === 'number') {
                    const dx = target.x - player.x;
                    const dy = target.y - player.y;
                    player.angle = Math.atan2(dy, dx);
                }
                shoot();
            } catch (err) {
                console.error('Auto-aim error:', err);
                shoot(); // Shoot anyway even if auto-aim fails
            }
        }

        function playShotgunSound() {
            try {
                const ac = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ac.createOscillator(), gain = ac.createGain();
                osc.connect(gain);
                gain.connect(ac.destination);
                osc.frequency.setValueAtTime(120, ac.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, ac.currentTime + 0.3);
                gain.gain.setValueAtTime(0.3, ac.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ac.currentTime + 0.3);
                osc.start(ac.currentTime);
                osc.stop(ac.currentTime + 0.3);
            } catch(e) {}
        }

        function updateHUD() {
            document.getElementById('stage').textContent = gameState.stage;
            document.getElementById('zombies-left').textContent = gameState.zombiesLeft;
            document.getElementById('zombies-killed').textContent = gameState.zombiesKilled;
            document.getElementById('ammo-count').textContent = gameState.playerAmmo;
            document.getElementById('start-stage').textContent = gameState.stage;
            document.getElementById('start-zombies').textContent = CONFIG.ZOMBIES_PER_STAGE[gameState.stage - 1];
        }

        function updateLivesDisplay() {
            const hearts = document.querySelectorAll('.life-heart');
            hearts.forEach((h, i) => {
                if (i < gameState.playerLives) h.classList.remove('empty');
                else h.classList.add('empty');
            });
        }

        function completeStage() {
            gameState.stageComplete = true;
            gameState.gameRunning = false;
            stopStageMusic();
            document.getElementById('completed-stage').textContent = gameState.stage;
            document.getElementById('completed-kills').textContent = gameState.zombiesKilled;
            document.getElementById('completed-ammo').textContent = gameState.totalAmmoCollected;
            if (gameState.stage < CONFIG.TOTAL_STAGES) {
                document.getElementById('next-stage-zombies').textContent = CONFIG.ZOMBIES_PER_STAGE[gameState.stage];
            } else {
                document.getElementById('next-stage-zombies').textContent = "ALL DONE!";
            }
            document.getElementById('stage-complete-screen').classList.remove('hidden');
        }

        function nextStage() {
            gameState.stage++;
            if (gameState.stage > CONFIG.TOTAL_STAGES) {
                alert("You won all 10 stages!");
                restartGame();
                return;
            }
            
            // Award one extra life for completing stage (max 5 lives)
            if (gameState.playerLives < 5) {
                gameState.playerLives++;
            }
            
            // Hide stage complete screen
            document.getElementById('stage-complete-screen').classList.add('hidden');
            
            // Play cutscene for stages 2-5, otherwise start immediately
            if (gameState.stage >= 2 && gameState.stage <= 5) {
                playCutscene('stage', gameState.stage);
            } else {
                // No cutscene for stages 6-10, start immediately
                startStageDirectly();
            }
            
            // Save progress
            saveGame();
        }
        
        function startStageDirectly() {
            // Setup stage without cutscene
            gameState.zombiesLeft = CONFIG.ZOMBIES_PER_STAGE[gameState.stage - 1];
            gameState.zombiesKilled = 0;
            zombies.length = 0;
            ammoPacks.length = 0;
            bulletTraces.length = 0;
            bloodSplatters.length = 0;
            bosses.length = 0;
            gameState.bossActive = false;
            gameState.bossPlayedSound = false;
            
            spawnInitialZombies();
            spawnHiddenAmmo();
            spawnBoss();  // Spawn boss(es) on every stage
            
            gameState.stageComplete = false;
            gameState.gameRunning = true;
            updateLivesDisplay();
            
            // Play new stage music
            playStageMusic(gameState.stage);
        }

        function gameOver() {
            gameState.gameOver = true;
            gameState.gameRunning = false;
            stopStageMusic();
            document.getElementById('final-stage').textContent = gameState.stage;
            document.getElementById('final-kills').textContent = gameState.zombiesKilled;
            document.getElementById('final-ammo').textContent = gameState.totalAmmoCollected;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        function applyDifficulty(difficulty) {
            gameState.difficulty = difficulty;
            const preset = DIFFICULTY_PRESETS[difficulty];
            
            // Apply difficulty settings
            CONFIG.ZOMBIE_SPEED_MIN = preset.ZOMBIE_SPEED_MIN;
            CONFIG.ZOMBIE_SPEED_MAX = preset.ZOMBIE_SPEED_MAX;
            CONFIG.BOSS_SPEED = preset.BOSS_SPEED;
            ACID_CONFIG.RANGE = preset.ACID_RANGE;
            CONFIG.STARTING_LIVES = preset.STARTING_LIVES;
            
            // Update lives display
            gameState.playerLives = preset.STARTING_LIVES;
        }
        
        function restartGame() {
            stopStageMusic();
            clearSave();  // Clear save on restart
            gameState = {
                stage: 1,
                zombiesKilled: 0,
                zombiesLeft: CONFIG.ZOMBIES_PER_STAGE[0],
                playerLives: CONFIG.STARTING_LIVES,
                playerAmmo: CONFIG.STARTING_AMMO,
                totalAmmoCollected: 0,
                gameRunning: false,
                gameOver: false,
                stageComplete: false,
                lastShotTime: 0,
                lastHitTime: 0,
                zoom: CONFIG.DEFAULT_ZOOM,
                isInvincible: false,
                bossActive: false,
                bossPlayedSound: false,
                isPaused: false
            };
            player.x = CONFIG.CANVAS_WIDTH / 2;
            player.y = CONFIG.CANVAS_HEIGHT / 2;
            zombies.length = 0;
            ammoPacks.length = 0;
            bulletTraces.length = 0;
            bloodSplatters.length = 0;
            bosses.length = 0;
            
            initBuildings();
            spawnInitialZombies();
            spawnHiddenAmmo();
            spawnBoss();
            
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('stage-complete-screen').classList.add('hidden');
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
            updateHUD();
            updateLivesDisplay();
        }

        window.addEventListener('load', initGame);
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
